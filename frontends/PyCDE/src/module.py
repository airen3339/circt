#  Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
#  See https://llvm.org/LICENSE.txt for license information.
#  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

from __future__ import annotations
from typing import List, Optional, Tuple, Union, Dict
from pycde.pycde_types import ClockType

from pycde.support import _obj_to_value

from .common import (AppID, Clock, Input, Output, PortError, _PyProxy)
from .support import (get_user_loc, _obj_to_attribute, OpOperandConnect,
                      create_type_string, create_const_zero)
from .value import ClockSignal, Signal, Value

from .circt import ir, support
from .circt.dialects import hw, msft
from .circt.support import BackedgeBuilder, attribute_to_var

import builtins
from contextvars import ContextVar
import inspect
import sys

# A memoization table for module parameterization function calls.
_MODULE_CACHE: Dict[Tuple[builtins.function, ir.DictAttr], object] = {}


def _create_module_name(name: str, params: ir.DictAttr):
  """Create a "reasonable" module name from a base name and a set of
  parameters. E.g. PolyComputeForCoeff_62_42_6."""

  def val_str(val):
    if isinstance(val, ir.Type):
      return create_type_string(val)
    if isinstance(val, ir.Attribute):
      return str(attribute_to_var(val))
    return str(val)

  param_strings = []
  for p in params:
    param_strings.append(p.name + val_str(p.attr))
  for ps in sorted(param_strings):
    name += "_" + ps

  ret = ""
  name = name.replace("!hw.", "")
  for c in name:
    if c.isalnum():
      ret = ret + c
    elif c not in "!>[],\"" and len(ret) > 0 and ret[-1] != "_":
      ret = ret + "_"
  return ret.strip("_")


def _get_module_cache_key(func,
                          params) -> Tuple[builtins.function, ir.DictAttr]:
  """The "module" cache is specifically for parameterized modules. It maps the
  module parameterization function AND parameter values to the class which was
  generated by a previous call to said module parameterization function."""
  if not isinstance(params, ir.DictAttr):
    params = _obj_to_attribute(params)
  return (func, params)


_current_block_context = ContextVar("current_block_context")


class _BlockContext:
  """Bookkeeping for a scope."""

  def __init__(self):
    self.symbols: set[str] = set()

  @staticmethod
  def current() -> _BlockContext:
    """Get the top-most context in the stack created by `with
    _BlockContext()`."""
    bb = _current_block_context.get(None)
    assert bb is not None
    return bb

  def __enter__(self):
    self._old_system_token = _current_block_context.set(self)

  def __exit__(self, exc_type, exc_value, traceback):
    if exc_value is not None:
      return
    _current_block_context.reset(self._old_system_token)

  def uniquify_symbol(self, sym: str) -> str:
    """Create a unique symbol and add it to the cache. If it is to be preserved,
    the caller must use it as the symbol on a top-level op."""
    ctr = 0
    ret = sym
    while ret in self.symbols:
      ctr += 1
      ret = sym + "_" + str(ctr)
    self.symbols.add(ret)
    return ret


class Generator:
  """
  Represents a generator. Stores the generate function and location of
  the generate call. Generator objects are passed to module-specific generator
  object handlers.
  """

  def __init__(self, gen_func):
    self.gen_func = gen_func
    self.loc = get_user_loc()


def generator(func):
  """Decorator for generation functions."""
  return Generator(func)


###############################################################################
# New style Modules.
###############################################################################


class ModuleLikeBuilder(_PyProxy):

  def __init__(self, cls, cls_dct, loc):
    self.modcls = cls
    self.cls_dct = cls_dct
    self.loc = loc
    self.parameters = None
    self.set_name()

  def go(self):
    self.scan_cls()
    self.generator_port_proxy = self.create_port_proxy()
    self.add_external_port_accessors()

  def scan_cls(self):
    # Inputs, Outputs, and parameters are all class members. We must populate
    # them. Scan 'dct' for them.
    input_ports = []
    output_ports = []
    clock_ports = set()
    generators = {}
    for attr_name, attr in self.cls_dct.items():
      if attr_name.startswith("_"):
        continue

      if isinstance(attr, Clock):
        clock_ports.add(len(input_ports))
        input_ports.append((attr_name, ir.IntegerType.get_signless(1)))
      elif isinstance(attr, Input):
        input_ports.append((attr_name, attr.type))
      elif isinstance(attr, Output):
        output_ports.append((attr_name, attr.type))
      elif isinstance(attr, Generator):
        generators[attr_name] = attr

    self.outputs = output_ports
    self.inputs = input_ports
    self.clocks = clock_ports
    self.generators = generators

  def create_port_proxy(self):
    proxy_attrs = {}
    for idx, (name, port_type) in enumerate(self.inputs):
      proxy_attrs[name] = property(
          lambda self, idx=idx, gs=self: gs.get_input(idx))

    for idx, (name, port_type) in enumerate(self.outputs):

      def fget(self, idx=idx, builder=self):
        builder.get_output(idx)

      def fset(self, val, idx=idx, builder=self):
        builder.set_output(idx, val)

      proxy_attrs[name] = property(fget=fget, fset=fset)

    return type(self.modcls.__name__ + "Builder", (), proxy_attrs)

  def add_external_port_accessors(self):
    for idx, (name, port_type) in enumerate(self.inputs):

      def fget(self):
        raise PortError("Cannot access signal via instance input")

      setattr(self.modcls, name, property(fget=fget))

    for idx, (name, port_type) in enumerate(self.outputs):

      def fget(self, idx=idx):
        return Value(self.inst.results[idx])

      setattr(self.modcls, name, property(fget=fget))

  def reset_generate(self, args=None):
    """Resets member variables to their defaults. Should be called before and
    after each generate."""
    self.block_args = args
    self.output_values = [None] * len(self.outputs)

  def set_name(self):
    if hasattr(self.modcls, "module_name"):
      self.name = self.modcls.module_name
    elif self.parameters is not None:
      self.name = _create_module_name(self.modcls.__name__, self.parameters)
    else:
      self.name = self.modcls.__name__

  def set_params(self, params: ir.DictAttr):
    self.parameters = params
    self.set_name()

  def get_input(self, idx):
    val = self.block_args[idx]
    if idx in self.clocks:
      return ClockSignal(val, ClockType())
    return Value(val)

  def set_output(self, idx, signal):
    assert signal is not None
    pname, ptype = self.outputs[idx]
    if isinstance(signal, Signal):
      if ptype != signal.type:
        raise PortError(
            f"Input port {pname} expected type {ptype}, not {signal.type}")
    else:
      signal = _obj_to_value(signal, ptype)
    self.output_values[idx] = signal

  def check_unconnected_outputs(self):
    unconnected_ports = []
    for idx, value in enumerate(self.output_values):
      if value is None:
        unconnected_ports.append(self.outputs[idx][0])
    if len(unconnected_ports) > 0:
      raise support.UnconnectedSignalError(self.name, unconnected_ports)

  def print(self, out):
    print(
        f"<pycde.Module: {self.name} inputs: {self.inputs} "
        f"outputs: {self.outputs}>",
        file=out)


class ModuleLikeType(type):
  """ModuleLikeType is a metaclass for Module and other things which look like
  modules (e.g. ServiceGenerators). It reads the ports and constructs a builder
  to give access to the module ports."""

  def __init__(cls, name, bases, dct: Dict):
    super(ModuleLikeType, cls).__init__(name, bases, dct)
    cls._builder = cls.BuilderType(cls, dct, get_user_loc())
    cls._builder.go()


class ModuleSpec(ModuleLikeBuilder):

  @property
  def circt_mod(self):
    from .system import System
    sys: System = System.current()
    ret = sys._op_cache.get_circt_mod(self)
    if ret is None:
      return sys._create_circt_mod(self)
    return ret

  def create_op(self, sys, symbol):
    """Creation callback for creating a MSFTModuleOp."""
    if len(self.generators) > 0:
      return msft.MSFTModuleOp(
          symbol,
          self.inputs,
          self.outputs,
          self.parameters if hasattr(self, "parameters") else None,
          loc=self.loc,
          ip=sys._get_ip())

    if self.parameters is None:
      paramdecl_list = []
    else:
      paramdecl_list = [
          hw.ParamDeclAttr.get_nodefault(i.name, i.attr.type)
          for i in self.parameters
      ]
    return msft.MSFTModuleExternOp(
        symbol,
        self.inputs,
        self.outputs,
        parameters=paramdecl_list,
        attributes={"verilogName": ir.StringAttr.get(self.name)},
        loc=self.loc,
        ip=sys._get_ip())

  def instantiate(self, module_inst, instance_name: str, **inputs):
    from .circt.dialects import _hw_ops_ext as hwext
    circt_mod = self.circt_mod
    input_lookup = {
        name: (idx, ptype) for idx, (name, ptype) in enumerate(self.inputs)
    }
    input_values: List[Optional[Signal]] = [None] * len(self.inputs)
    for name, signal in inputs.items():
      if name not in input_lookup:
        raise PortError(f"Input port {name} not found in module")
      idx, ptype = input_lookup[name]
      if isinstance(signal, Signal):
        if ptype != signal.type:
          raise PortError(
              f"Input port {name} expected type {ptype}, not {signal.type}")
      else:
        signal = _obj_to_value(signal, ptype)
      input_values[idx] = signal
      del input_lookup[name]
    if len(input_lookup) > 0:
      missing = ", ".join(list(input_lookup.keys()))
      raise ValueError(f"Missing input signals for ports: {missing}")

    parameters = None
    if len(self.generators) == 0 and self.parameters is not None:
      parameters = ir.ArrayAttr.get(
          hwext.create_parameters(self.parameters, circt_mod))
    inst = msft.InstanceOp(circt_mod.type.results,
                           instance_name,
                           ir.FlatSymbolRefAttr.get(
                               ir.StringAttr(
                                   circt_mod.attributes["sym_name"]).value),
                           [sig.value for sig in input_values],
                           parameters=parameters,
                           loc=get_user_loc())
    inst.verify()
    return inst

  def generate(self):
    """Fill in (generate) this module. Only supports a single generator
    currently."""
    assert len(self.generators) == 1
    g: Generator = list(self.generators.values())[0]

    def create_output_op():
      """Create the hw.OutputOp from module I/O ports in 'args'."""
      self.check_unconnected_outputs()
      msft.OutputOp([o.value for o in self.output_values])

    bc = _BlockContext()
    circt_mod = self.circt_mod
    entry_block = circt_mod.add_entry_block()
    self.reset_generate(entry_block.arguments)
    builder = self.generator_port_proxy()
    with ir.InsertionPoint(entry_block), g.loc, BackedgeBuilder(), bc:
      # Enter clock block implicitly if only one clock given.
      clk = None
      if len(self.clocks) == 1:
        clk_port = list(self.clocks)[0]
        clk = ClockSignal(self.block_args[clk_port], ClockType())
        clk.__enter__()

      outputs = g.gen_func(builder)
      if outputs is not None:
        raise ValueError("Generators must not return a value")
      if create_output_op is not None:
        create_output_op()

      if clk is not None:
        clk.__exit__(None, None, None)
    self.reset_generate()


class Module(metaclass=ModuleLikeType):
  BuilderType = ModuleSpec

  def __init__(self, instance_name: str = None, appid: AppID = None, **inputs):
    """Create an instance of this module."""
    if instance_name is None:
      instance_name = self.__class__.__name__
    instance_name = _BlockContext.current().uniquify_symbol(instance_name)
    self.inst = self._builder.instantiate(self, instance_name, **inputs)
    if appid is not None:
      self.inst.operation.attributes[AppID.AttributeName] = appid._appid

  @classmethod
  def print(cls, out=sys.stdout):
    cls._builder.print(out)


class params:
  """When the @module decorator detects that it is decorating a function, use
  this class to wrap it."""

  func = None

  # When the decorator is attached, this runs.
  def __init__(self, func: builtins.function):

    # If it's a module parameterization function, inspect the arguments to
    # ensure sanity.
    self.func = func
    self.sig = inspect.signature(self.func)
    for (_, param) in self.sig.parameters.items():
      if param.kind == param.VAR_KEYWORD:
        raise TypeError("Module parameter definitions cannot have **kwargs")
      if param.kind == param.VAR_POSITIONAL:
        raise TypeError("Module parameter definitions cannot have *args")

  # This function gets executed in two situations:
  #   - In the case of a module function parameterizer, it is called when the
  #   user wants to apply specific parameters to the module. In this case, we
  #   should call the function, wrap the returned module class, and return it.
  #   The result is cached in _MODULE_CACHE.
  #   - A simple (non-parameterized) module has been wrapped and the user wants
  #   to construct one. Just forward to the module class' constructor.
  def __call__(self, *args, **kwargs):
    assert self.func is not None
    param_values = self.sig.bind(*args, **kwargs)
    param_values.apply_defaults()

    # Function arguments which start with '_' don't become parameters.
    params = {
        n: v for n, v in param_values.arguments.items() if not n.startswith("_")
    }

    # Check cache
    cache_key = _get_module_cache_key(self.func, params)
    if cache_key in _MODULE_CACHE:
      return _MODULE_CACHE[cache_key]

    cls = self.func(*args, **kwargs)
    if not issubclass(cls, Module):
      raise ValueError("Parameterization function must return Module class")

    cls._builder.set_params(cache_key[1])
    _MODULE_CACHE[cache_key] = cls
    return cls


class ImportedModSpec(ModuleSpec):
  # Creation callback that just moves the already build module into the System's
  # ModuleOp and returns it.
  def create_op(self, sys, symbol: str):
    hw_module = self.modcls.hw_module

    # TODO: deal with symbolrefs to this (potentially renamed) module symbol.
    sys.mod.body.append(hw_module)

    # Need to clear out the reference to ourselves so that we can release the
    # raw reference to `hw_module`. It's safe to do so since unlike true PyCDE
    # modules, this can only be run once during the import_mlir.
    self.modcls.hw_module = None
    return hw_module

  def instantiate(self, module_inst, instance_name: str, **inputs):
    inst = self.circt_mod.instantiate(
        instance_name,
        **inputs,
        parameters={} if self.parameters is None else self.parameters,
        loc=get_user_loc())
    inst.operation.verify()
    return inst.operation


def import_hw_module(hw_module: hw.HWModuleOp):
  # Get the module name to use in the generated class and as the external name.
  name = ir.StringAttr(hw_module.name).value

  # Collect input and output ports as named Inputs and Outputs.
  modattrs = {}
  for input_name, block_arg in hw_module.inputs().items():
    modattrs[input_name] = Input(block_arg.type, input_name)
  for output_name, output_type in hw_module.outputs().items():
    modattrs[output_name] = Output(output_type, output_name)
  modattrs["BuilderType"] = ImportedModSpec
  modattrs["hw_module"] = hw_module

  # Use the name and ports to construct a class object like what externmodule
  # would wrap.
  cls = type(name, (Module,), modattrs)

  return cls
