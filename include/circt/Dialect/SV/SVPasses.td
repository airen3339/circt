//===-- SVPasses.td - SV pass definition file --------------*- tablegen -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file contains definitions for passes that work on the SV dialect.
//
//===----------------------------------------------------------------------===//

#ifndef CIRCT_DIALECT_SV_SVPASSES
#define CIRCT_DIALECT_SV_SVPASSES

include "mlir/Pass/PassBase.td"

def HWCleanup : Pass<"hw-cleanup", "hw::HWModuleOp"> {
  let summary = "Cleanup transformations for operations in hw.module bodies";
  let description = [{
      This pass merges sv.alwaysff operations with the same condition, sv.ifdef
      nodes with the same condition, and perform other cleanups for the IR.
      This is a good thing to run early in the HW/SV pass pipeline to expose
      opportunities for other simpler passes (like canonicalize).
  }];

  let constructor = "circt::sv::createHWCleanupPass()";
}

def PrettifyVerilog : Pass<"prettify-verilog", "hw::HWModuleOp"> {
  let summary = "Transformations to improve quality of ExportVerilog output";
  let description = [{
      This pass contains elective transformations that improve the quality of
      SystemVerilog generated by the ExportVerilog library.  This pass is not
      compulsory: things that are required for ExportVerilog to be correct
      should be included as part of the ExportVerilog pass itself to make sure
      it is self contained.
  }];

  let constructor = "circt::sv::createPrettifyVerilogPass()";
}

def HWStubExternalModules : Pass<"hw-stub-external-modules", 
                                  "mlir::ModuleOp"> {
  let summary = "transform external hw modules to empty hw modules";
  let description = [{
      This pass creates empty module bodies for external modules.  This is
      useful for linting to eliminate missing file errors.
  }];

  let constructor = "circt::sv::createHWStubExternalModulesPass()";
  let dependentDialects = ["circt::sv::SVDialect"];
}

def HWLegalizeNames : Pass<"hw-legalize-names", "ModuleOp"> {
  let summary = "Legalize module/variable names in hw.modules and their bodies";
  let description = [{
    This pass modifies the names of modules and names such that they do not
    cause conflicts with SV keywords. This is a good thing to run before
    Verilog emission.
  }];

  let constructor = "circt::sv::createHWLegalizeNamesPass()";
}

def HWGeneratorCalloutPass : Pass<"hw-generator-callout", "ModuleOp"> {
  let summary = "Lower Generator Schema to external module";
  let description = [{
    This pass calls an external program for all the hw.module.generated nodes,
    following the description in the hw.generator.schema node.
  }];
  let constructor = "circt::sv::createHWGeneratorCalloutPass()";

  let options = [
    Option<"schemaName", "schema-name", "std::string",
                "", "Name of the schema to process">,
    Option<"genExecutable", "generator-executable", "std::string",
                "", "Generator program executable with optional full path">,
    Option<"genExecArgs", "generator-executable-arguments", "std::string",
                "", "Generator program arguments separated by ;">,
   ];
}

def HWMemSimImpl : Pass<"hw-memory-sim", "ModuleOp"> {
  let summary = "Implement FIRRTMMem memories nodes with simulation model";
  let description = [{
    This pass replaces generated module nodes of type FIRRTLMem with a model
    suitable for simulation.
  }];

  let constructor = "circt::sv::createHWMemSimImplPass()";
  let dependentDialects = ["circt::sv::SVDialect"];
}

def HWDeclareTypedecls : Pass<"hw-declare-typedecls", "ModuleOp"> {
  let summary = "Declare TypedeclOps for any TypeAlias types";
  let description = [{
    This pass finds any TypeAlias types uses as operands, results, or block
    arguments, and declares TypedeclOps in the top-level module using the name
    and type from the TypeAlias. This should be used as a pre-processing step
    before Verilog emission to ensure TypeAliases used throughout the circuit
    have a typedecl.
  }];

  let constructor = "circt::sv::createHWDeclareTypedeclsPass()";
}

#endif // CIRCT_DIALECT_SV_SVPASSES
