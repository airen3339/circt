//===--- Passes.td - Moore pass definition file ------------*- tablegen -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines the passes that work on the Moore dialect.
//
//===----------------------------------------------------------------------===//

#ifndef CIRCT_DIALECT_MOORE_MOOREPASSES_TD
#define CIRCT_DIALECT_MOORE_MOOREPASSES_TD

include "mlir/Pass/PassBase.td"

def SimplifyProcedures : Pass<"moore-simplify-procedures", "moore::SVModuleOp"> {
    let summary = "Simplify procedures";
    let description = [{
      Because we want to introduce mem2reg in the moore dialect to eliminate the
      local temporary variables, if the local variabels exist in the procedure
      body, it can be promoted by mem2reg. But global/module-level variables
      don't be promoted. So this pass is aimed at inserting a local "shadow"
      variable in always blocks for every module-level variable that the
      process modifies. Then perform mem2reg to eliminate the local "shadow"
      variable.
    }];
    let constructor = "circt::moore::createSimplifyProceduresPass()";
}

def Dedup : Pass<"moore-dedup", "mlir::ModuleOp"> {
  let summary = "Deduplicate modules which are generated by same instance in SV";
  let description = [{
    This pass detects modules which are structurally equivalent and removes the
    duplicate module by replacing all instances of one with the other.
    This pass is only suitable for software simulation. Different symbolName
    modules relate to different hardware units in hardware simulation. So this pass
    is not recommended in hardware simulation.
    For example,
    ```
    module {
    moore.module @top() {
      %a = moore.net wire : <l4>
      %0 = moore.read %a : l4
      moore.instance "insA" @NestedA(a: %0: !moore.l4) -> ()
      %1 = moore.read %a : l4
      --- moore.instance "insB" @NestedA_0(a: %1: !moore.l4) -> ()
      +++ moore.instance "insB" @NestedA(a: %1: !moore.l4) -> ()
      moore.output
      }
      --- moore.module @NestedA_0(in %a : !moore.l4) {
      ---   %a_0 = moore.net name "a" wire : <l4>
      ---   moore.assign %a_0, %a : l4
      ---   moore.output
      --- }
      moore.module @NestedA(in %a : !moore.l4) {
      %a_0 = moore.net name "a" wire : <l4>
      moore.assign %a_0, %a : l4
      moore.output
      }
    }
    ```
  }];
  let constructor = "circt::moore::createDedupPass()";
}

#endif // CIRCT_DIALECT_MOORE_MOOREPASSES_TD
