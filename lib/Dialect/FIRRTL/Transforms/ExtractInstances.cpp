//===- ExtractInstances.cpp - Move instances up the hierarchy ---*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// Moves annotated instances upwards in the module hierarchy. Corresponds to the
// `ExtractBlackBoxes`, `ExtractClockGates`, and `ExtractSeqMems` passes in the
// Scala FIRRTL implementation.
//
//===----------------------------------------------------------------------===//

#include "PassDetails.h"
#include "circt/Dialect/FIRRTL/AnnotationDetails.h"
#include "circt/Dialect/FIRRTL/FIRRTLAnnotations.h"
#include "circt/Dialect/FIRRTL/FIRRTLInstanceGraph.h"
#include "circt/Dialect/FIRRTL/NLATable.h"
#include "circt/Dialect/FIRRTL/Namespace.h"
#include "circt/Dialect/FIRRTL/Passes.h"
#include "circt/Dialect/HW/HWAttributes.h"
#include "circt/Dialect/HW/HWDialect.h"
#include "circt/Dialect/SV/SVOps.h"
#include "circt/Support/Path.h"
#include "mlir/IR/Attributes.h"
#include "mlir/IR/ImplicitLocOpBuilder.h"
#include "mlir/Support/FileUtilities.h"
#include "llvm/ADT/SmallPtrSet.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/Path.h"

#define DEBUG_TYPE "firrtl-extract-instances"

using namespace circt;
using namespace firrtl;
using hw::InnerRefAttr;

//===----------------------------------------------------------------------===//
// Pass Implementation
//===----------------------------------------------------------------------===//

namespace {
/// All information necessary to move instances about.
struct ExtractionInfo {
  /// A filename into which the performed hierarchy modifications are emitted.
  StringRef traceFilename;
  /// A prefix to attach to the wiring generated by the extraction.
  StringRef prefix;
  /// Optional name of the wrapper module that will hold the moved instance.
  StringRef wrapperModule;
  /// Whether the extraction should stop at the root of the DUT instead of going
  /// past that and extracting into the test harness.
  bool stopAtDUT;
};

struct ExtractInstancesPass
    : public ExtractInstancesBase<ExtractInstancesPass> {
  void runOnOperation() override;
  void collectAnnos();
  void collectAnno(InstanceOp inst, Annotation anno);
  void extractInstances();
  void groupInstances();
  void createTraceFiles();

  /// Get the cached namespace for a module.
  ModuleNamespace &getModuleNamespace(FModuleLike module) {
    auto it = moduleNamespaces.find(module);
    if (it != moduleNamespaces.end())
      return it->second;
    return moduleNamespaces.try_emplace(module, ModuleNamespace(module))
        .first->second;
  }

  /// Returns an operation's `inner_sym`, adding one if necessary.
  StringAttr getOrAddInnerSym(Operation *op) {
    auto attr = op->getAttrOfType<StringAttr>("inner_sym");
    if (attr)
      return attr;
    auto module = op->getParentOfType<FModuleOp>();
    auto name = getModuleNamespace(module).newName("extraction_sym");
    attr = StringAttr::get(op->getContext(), name);
    op->setAttr("inner_sym", attr);
    return attr;
  }

  /// Obtain an inner reference to an operation, possibly adding an `inner_sym`
  /// to that operation.
  InnerRefAttr getInnerRefTo(Operation *op) {
    return InnerRefAttr::get(
        SymbolTable::getSymbolName(op->getParentOfType<FModuleOp>()),
        getOrAddInnerSym(op));
  }

  bool anythingChanged;
  bool anyFailures;

  InstanceGraph *instanceGraph = nullptr;

  /// The modules in the design that are annotated with one or more annotations
  /// relevant for instance extraction.
  DenseMap<Operation *, SmallVector<Annotation, 1>> annotatedModules;

  /// All modules that are marked as DUT themselves. Realistically this is only
  /// ever one module in the design.
  DenseSet<Operation *> dutRootModules;
  /// All modules that are marked as DUT themselves, or that have a DUT parent
  /// module.
  DenseSet<Operation *> dutModules;
  /// All DUT module names.
  DenseSet<Attribute> dutModuleNames;

  /// A worklist of instances that need to be moved.
  SmallVector<std::pair<InstanceOp, ExtractionInfo>> extractionWorklist;

  /// The path along which instances have been extracted. This essentially
  /// documents the original location of the instance in reverse. Every push
  /// upwards in the hierarchy adds another entry to this path documenting along
  /// which instantiation path each instance was extracted.
  DenseMap<Operation *, SmallVector<InnerRefAttr>> extractionPaths;

  /// A map of the original parent modules of instances before they were
  /// extracted. This is used in a corner case during trace file emission.
  DenseMap<Operation *, StringAttr> originalInstanceParents;

  /// All extracted instances in their position after moving upwards in the
  /// hierarchy, but before being grouped into an optional submodule.
  SmallVector<std::pair<InstanceOp, ExtractionInfo>> extractedInstances;

  // The uniquified wiring prefix for each instance.
  DenseMap<Operation *, SmallString<16>> instPrefices;

  /// The current circuit namespace valid within the call to `runOnOperation`.
  CircuitNamespace circuitNamespace;
  /// Cached module namespaces.
  DenseMap<Operation *, ModuleNamespace> moduleNamespaces;
};
} // end anonymous namespace

/// Emit the annotated source code for black boxes in a circuit.
void ExtractInstancesPass::runOnOperation() {
  CircuitOp circuitOp = getOperation();
  anythingChanged = false;
  anyFailures = false;
  annotatedModules.clear();
  dutRootModules.clear();
  dutModules.clear();
  extractionWorklist.clear();
  extractionPaths.clear();
  originalInstanceParents.clear();
  extractedInstances.clear();
  instPrefices.clear();
  moduleNamespaces.clear();
  circuitNamespace.clear();
  circuitNamespace.add(circuitOp);

  // Walk the IR and gather all the annotations relevant for extraction that
  // appear on instances and the instantiated modules.
  instanceGraph = &getAnalysis<InstanceGraph>();
  collectAnnos();
  if (anyFailures)
    return signalPassFailure();

  // Actually move instances upwards.
  extractInstances();
  if (anyFailures)
    return signalPassFailure();

  // Group instances into submodules, if requested.
  groupInstances();
  if (anyFailures)
    return signalPassFailure();

  // Generate the trace files that list where each instance was extracted from.
  createTraceFiles();
  if (anyFailures)
    return signalPassFailure();

  // If nothing has changed we can preseve the analysis.
  LLVM_DEBUG(llvm::dbgs() << "\n");
  if (!anythingChanged)
    markAllAnalysesPreserved();
  markAnalysesPreserved<InstanceGraph>();
}

static bool isAnnoInteresting(Annotation anno) {
  return anno.isClass(extractBlackBoxAnnoClass);
}

/// Gather the modules and instances annotated to be moved by this pass. This
/// populates the corresponding lists and maps of the pass.
void ExtractInstancesPass::collectAnnos() {
  CircuitOp circuit = getOperation();

  // Grab the clock gate extraction annotation on the circuit.
  StringRef clkgateFileName;
  StringRef clkgateWrapperModule;
  AnnotationSet::removeAnnotations(circuit, [&](Annotation anno) {
    if (!anno.isClass(extractClockGatesAnnoClass))
      return false;
    LLVM_DEBUG(llvm::dbgs()
               << "Clock gate extraction config: " << anno.getDict() << "\n");
    auto filenameAttr = anno.getMember<StringAttr>("filename");
    auto groupAttr = anno.getMember<StringAttr>("group");
    if (!filenameAttr) {
      circuit.emitError("missing `filename` attribute in `")
          << anno.getClass() << "` annotation";
      anyFailures = true;
      return true;
    }

    if (!clkgateFileName.empty()) {
      circuit.emitError("multiple `")
          << anno.getClass() << "` annotations on circuit";
      anyFailures = true;
      return true;
    }

    clkgateFileName = filenameAttr.getValue();
    if (groupAttr)
      clkgateWrapperModule = groupAttr.getValue();
    return true;
  });

  // Grab the memory extraction annotation on the circuit.
  StringRef memoryFileName;
  StringRef memoryWrapperModule;
  AnnotationSet::removeAnnotations(circuit, [&](Annotation anno) {
    if (!anno.isClass(extractSeqMemsAnnoClass))
      return false;
    LLVM_DEBUG(llvm::dbgs()
               << "Memory extraction config: " << anno.getDict() << "\n");
    auto filenameAttr = anno.getMember<StringAttr>("filename");
    auto groupAttr = anno.getMember<StringAttr>("group");
    if (!filenameAttr) {
      circuit.emitError("missing `filename` attribute in `")
          << anno.getClass() << "` annotation";
      anyFailures = true;
      return true;
    }

    if (!memoryFileName.empty()) {
      circuit.emitError("multiple `")
          << anno.getClass() << "` annotations on circuit";
      anyFailures = true;
      return true;
    }

    memoryFileName = filenameAttr.getValue();
    if (groupAttr)
      memoryWrapperModule = groupAttr.getValue();
    return true;
  });

  // Gather the annotations on modules. These complement the later per-instance
  // annotations.
  for (auto module : circuit.getOps<FModuleLike>()) {
    AnnotationSet::removeAnnotations(module, [&](Annotation anno) {
      if (anno.isClass(dutAnnoClass)) {
        LLVM_DEBUG(llvm::dbgs()
                   << "Marking DUT `" << module.moduleName() << "`\n");
        dutRootModules.insert(module);
        dutModules.insert(module);
        return false; // other passes may rely on this anno; keep it
      }
      if (!isAnnoInteresting(anno))
        return false;
      LLVM_DEBUG(llvm::dbgs() << "Annotated module `" << module.moduleName()
                              << "`:\n  " << anno.getDict() << "\n");
      annotatedModules[module].push_back(anno);
      return true;
    });
  }

  // Gather the annotations on instances to be extracted.
  circuit.walk([&](InstanceOp inst) {
    SmallVector<Annotation, 1> instAnnos;
    Operation *module = instanceGraph->getReferencedModule(inst);

    // Module-level annotations.
    auto it = annotatedModules.find(module);
    if (it != annotatedModules.end())
      instAnnos.append(it->second);

    // Instance-level annotations.
    AnnotationSet::removeAnnotations(inst, [&](Annotation anno) {
      if (!isAnnoInteresting(anno))
        return false;
      LLVM_DEBUG(llvm::dbgs() << "Annotated instance `" << inst.name()
                              << "`:\n  " << anno.getDict() << "\n");
      instAnnos.push_back(anno);
      return true;
    });

    // No need to do anything about unannotated instances.
    if (instAnnos.empty())
      return;

    // Ensure there are no conflicting annotations.
    if (instAnnos.size() > 1) {
      auto d = inst.emitError("multiple extraction annotations on instance `")
               << inst.name() << "`";
      d.attachNote(inst.getLoc()) << "instance has the following annotations, "
                                     "but at most one is allowed:";
      for (auto anno : instAnnos)
        d.attachNote(inst.getLoc()) << anno.getDict();
      anyFailures = true;
      return;
    }

    // Process the annotation.
    collectAnno(inst, instAnnos[0]);
  });

  // Propagate the DUT marking to all arbitrarily nested submodules of the DUT.
  LLVM_DEBUG(llvm::dbgs() << "Marking DUT hierarchy\n");
  SmallVector<InstanceGraphNode *> worklist;
  for (Operation *op : dutModules)
    worklist.push_back(instanceGraph->lookup(cast<hw::HWModuleLike>(op)));
  while (!worklist.empty()) {
    auto *module = worklist.pop_back_val();
    dutModuleNames.insert(module->getModule().moduleNameAttr());
    LLVM_DEBUG(llvm::dbgs()
               << "- " << module->getModule().moduleName() << "\n");
    for (auto *instRecord : *module) {
      auto *target = instRecord->getTarget();
      if (dutModules.insert(target->getModule()).second)
        worklist.push_back(target);
    }
  }

  // If clock gate extraction is requested, find instances of extmodules with
  // the corresponding `defname` and mark them as to be extracted.
  // TODO: This defname really shouldn't be hardcoded here. Make this at least
  // somewhat configurable.
  if (!clkgateFileName.empty()) {
    auto clkgateDefNameAttr = StringAttr::get(&getContext(), "EICG_wrapper");
    for (auto module : circuit.getOps<FExtModuleOp>()) {
      if (module.defnameAttr() != clkgateDefNameAttr)
        continue;
      LLVM_DEBUG(llvm::dbgs()
                 << "Clock gate `" << module.moduleName() << "`\n");
      if (!dutModules.contains(module)) {
        LLVM_DEBUG(llvm::dbgs() << "- Ignored (outside DUT)\n");
        continue;
      }

      ExtractionInfo info;
      info.traceFilename = clkgateFileName;
      info.prefix = "clock_gate"; // TODO: Don't hardcode this
      info.wrapperModule = clkgateWrapperModule;
      info.stopAtDUT = !info.wrapperModule.empty();
      for (auto *instRecord :
           instanceGraph->lookup(cast<hw::HWModuleLike>(*module))->uses()) {
        if (auto inst = dyn_cast<InstanceOp>(*instRecord->getInstance())) {
          LLVM_DEBUG(llvm::dbgs()
                     << "- Marking `"
                     << inst->getParentOfType<FModuleLike>().moduleName() << "."
                     << inst.name() << "`\n");
          extractionWorklist.push_back({inst, info});
        }
      }
    }
  }

  // If memory extraction is requested, find instances of `FMemModuleOp` and
  // mark them as to be extracted.
  // somewhat configurable.
  if (!memoryFileName.empty()) {
    for (auto module : circuit.getOps<FMemModuleOp>()) {
      LLVM_DEBUG(llvm::dbgs() << "Memory `" << module.moduleName() << "`\n");
      if (!dutModules.contains(module)) {
        LLVM_DEBUG(llvm::dbgs() << "- Ignored (outside DUT)\n");
        continue;
      }

      ExtractionInfo info;
      info.traceFilename = memoryFileName;
      info.prefix = "mem_wiring"; // TODO: Don't hardcode this
      info.wrapperModule = memoryWrapperModule;
      info.stopAtDUT = !info.wrapperModule.empty();
      for (auto *instRecord :
           instanceGraph->lookup(cast<hw::HWModuleLike>(*module))->uses()) {
        if (auto inst = dyn_cast<InstanceOp>(*instRecord->getInstance())) {
          LLVM_DEBUG(llvm::dbgs()
                     << "- Marking `"
                     << inst->getParentOfType<FModuleLike>().moduleName() << "."
                     << inst.name() << "`\n");
          extractionWorklist.push_back({inst, info});
        }
      }
    }
  }
}

/// Process an extraction annotation on an instance into a corresponding
/// `ExtractionInfo` and a spot on the worklist for later moving things around.
void ExtractInstancesPass::collectAnno(InstanceOp inst, Annotation anno) {
  LLVM_DEBUG(llvm::dbgs() << "Processing instance `" << inst.name() << "` "
                          << anno.getDict() << "\n");

  auto getStringOrError = [&](StringRef member) {
    auto attr = anno.getMember<StringAttr>(member);
    if (!attr) {
      inst.emitError("missing `")
          << member << "` attribute in `" << anno.getClass() << "` annotation";
      anyFailures = true;
    }
    return attr;
  };

  if (anno.isClass(extractBlackBoxAnnoClass)) {
    auto filename = getStringOrError("filename");
    auto prefix = getStringOrError("prefix");
    auto dest = anno.getMember<StringAttr>("dest"); // optional
    if (anyFailures)
      return;

    ExtractionInfo info;
    info.traceFilename = filename;
    info.prefix = prefix;
    info.wrapperModule = (dest ? dest.getValue() : "");

    // CAVEAT: If the instance has a wrapper module configured then extraction
    // should stop at the DUT module instead of extracting past the DUT into the
    // surrounding test harness. This is all very ugly and hacky.
    info.stopAtDUT = !info.wrapperModule.empty();

    extractionWorklist.push_back({inst, info});
    return;
  }
}

/// Move instances in the extraction worklist upwards in the hierarchy. This
/// iteratively pushes instances up one level of hierarchy until they have
/// arrived in the desired container module.
void ExtractInstancesPass::extractInstances() {
  // The list of ports to be added to an instance's parent module. Cleared and
  // reused across instances.
  SmallVector<std::pair<unsigned, PortInfo>> newPorts;
  // The number of instances with the same prefix. Used to uniquify prefices.
  DenseMap<StringRef, unsigned> prefixUniqueIDs;

  SmallPtrSet<Operation *, 4> nlasToRemove;
  SmallPtrSet<Attribute, 4> nlasToRemoveFromParent;

  auto &nlaTable = getAnalysis<NLATable>();

  // Keep track of where the instance was originally.
  for (auto &[inst, info] : extractionWorklist)
    originalInstanceParents[inst] =
        inst->getParentOfType<FModuleLike>().moduleNameAttr();

  while (!extractionWorklist.empty()) {
    InstanceOp inst;
    ExtractionInfo info;
    std::tie(inst, info) = extractionWorklist.pop_back_val();
    auto parent = inst->getParentOfType<FModuleOp>();

    // Figure out the wiring prefix to use for this instance. If we are supposed
    // to use a wiring prefix (`info.prefix` is non-empty), we assemble a
    // `<prefix>_<N>` string, where `N` is an unsigned integer used to uniquifiy
    // the prefix. This is very close to what the original Scala implementation
    // of the pass does, which would group instances to be extracted by prefix
    // and then iterate over them with the index in the group being used as `N`.
    StringRef prefix;
    if (!info.prefix.empty()) {
      auto &prefixSlot = instPrefices[inst];
      if (prefixSlot.empty()) {
        auto idx = prefixUniqueIDs[info.prefix]++;
        (Twine(info.prefix) + "_" + Twine(idx)).toVector(prefixSlot);
      }
      prefix = prefixSlot;
    }

    // If the instance is already in the right place (outside the DUT or already
    // in the root module), there's nothing left for us to do. Otherwise we
    // proceed to bubble it up one level in the hierarchy and add the resulting
    // instances back to the worklist.
    if (!dutModules.contains(parent) ||
        instanceGraph->lookup(parent)->noUses() ||
        (info.stopAtDUT && dutRootModules.contains(parent))) {
      LLVM_DEBUG(llvm::dbgs() << "\nNo need to further move " << inst << "\n");
      extractedInstances.push_back({inst, info});
      continue;
    }
    LLVM_DEBUG({
      llvm::dbgs() << "\nMoving ";
      if (!prefix.empty())
        llvm::dbgs() << "`" << prefix << "` ";
      llvm::dbgs() << inst << "\n";
    });

    // Add additional ports to the parent module as a replacement for the
    // instance port signals once the instance is extracted.
    unsigned numParentPorts = parent.getNumPorts();
    unsigned numInstPorts = inst.getNumResults();

    for (unsigned portIdx = 0; portIdx < numInstPorts; ++portIdx) {
      // Assemble the new port name as "<prefix>_<name>", where the prefix is
      // provided by the extraction annotation.
      auto name = inst.getPortNameStr(portIdx);
      auto nameAttr = StringAttr::get(
          &getContext(),
          prefix.empty() ? Twine(name) : Twine(prefix) + "_" + name);

      PortInfo newPort{nameAttr,
                       inst.getResult(portIdx).getType().cast<FIRRTLType>(),
                       direction::flip(inst.getPortDirection(portIdx))};
      newPort.loc = inst.getResult(portIdx).getLoc();
      newPorts.push_back({numParentPorts, newPort});
      LLVM_DEBUG(llvm::dbgs()
                 << "- Adding port " << newPort.direction << " "
                 << newPort.name.getValue() << ": " << newPort.type << "\n");
    }
    parent.insertPorts(newPorts);
    anythingChanged = true;

    // Replace all uses of the existing instance ports with the newly-created
    // module ports.
    for (unsigned portIdx = 0; portIdx < numInstPorts; ++portIdx) {
      inst.getResult(portIdx).replaceAllUsesWith(
          parent.getArgument(numParentPorts + portIdx));
    }
    assert(inst.use_empty() && "instance ports should have been detached");

    // Move the original instance one level up such that it is right next to
    // the instances of the parent module, and wire the instance ports up to
    // the newly added parent module ports.
    for (auto *instRecord :
         instanceGraph->lookup(cast<hw::HWModuleLike>(*parent))->uses()) {
      auto oldParentInst = cast<InstanceOp>(*instRecord->getInstance());
      auto newParent = oldParentInst->getParentOfType<FModuleLike>();
      LLVM_DEBUG(llvm::dbgs() << "- Updating " << oldParentInst << "\n");
      auto newParentInst = oldParentInst.cloneAndInsertPorts(newPorts);

      // Migrate connections to existing ports.
      for (unsigned portIdx = 0; portIdx < numParentPorts; ++portIdx)
        oldParentInst.getResult(portIdx).replaceAllUsesWith(
            newParentInst.getResult(portIdx));

      // Clone the existing instance and remove it from its current parent, such
      // that we can insert it at its extracted location.
      auto newInst = inst.cloneAndInsertPorts({});
      newInst->remove();

      // Ensure that the `inner_sym` of the instance is unique within the parent
      // module we're extracting it to.
      if (auto instSym = inst.inner_symAttr()) {
        auto newName =
            getModuleNamespace(newParent).newName(instSym.getValue());
        if (newName != instSym.getValue())
          newInst.inner_symAttr(StringAttr::get(&getContext(), newName));
      }

      // Add the moved instance and hook it up to the added ports.
      ImplicitLocOpBuilder builder(inst.getLoc(), newParentInst);
      builder.setInsertionPointAfter(newParentInst);
      builder.insert(newInst);
      for (unsigned portIdx = 0; portIdx < numInstPorts; ++portIdx) {
        auto dst = newInst.getResult(portIdx);
        auto src = newParentInst.getResult(numParentPorts + portIdx);
        if (newPorts[portIdx].second.direction == Direction::In)
          std::swap(src, dst);
        builder.create<StrictConnectOp>(dst, src);
      }

      // Move the wiring prefix from the old to the new instance. We just look
      // up the prefix for the old instance and if it exists, we remove it and
      // assign it to the new instance. This has the effect of making the first
      // new instance we create inherit the wiring prefix, and all additional
      // new instances (e.g. through multiple instantiation of the parent) will
      // pick a new prefix.
      auto oldPrefix = instPrefices.find(inst);
      if (oldPrefix != instPrefices.end()) {
        LLVM_DEBUG(llvm::dbgs()
                   << "  - Reusing prefix `" << oldPrefix->second << "`\n");
        auto newPrefix = std::move(oldPrefix->second);
        instPrefices.erase(oldPrefix);
        instPrefices.insert({newInst, newPrefix});
      }

      // Inherit the old instance's extraction path.
      auto &extractionPath = (extractionPaths[newInst] = extractionPaths[inst]);
      extractionPath.push_back(getInnerRefTo(newParentInst));
      originalInstanceParents[newInst] = originalInstanceParents[inst];

      // Update all NLAs that touch the moved instance. We do this through
      // `removeAnnotations` which gives us an opportunity to drop annotations
      // that we want to replace with an updated version. We add the new ones to
      // `newInstAnnos` since we cannot modify the `AnnotationSet` within
      // `removeAnnotations`.
      AnnotationSet annos(newInst);
      SmallVector<Attribute> newInstAnnos;
      annos.removeAnnotations([&](Annotation anno) {
        auto nlaName = anno.getMember<FlatSymbolRefAttr>("circt.nonlocal");
        if (!nlaName)
          return false;
        auto nla = nlaTable.getNLA(nlaName.getAttr());
        LLVM_DEBUG(llvm::dbgs() << "  - Updating " << nla << "\n");

        // Find the position of the instance in the NLA path. This is going to
        // be the position at which we have to modify the NLA.
        SmallVector<Attribute> nlaPath(nla.namepath().begin(),
                                       nla.namepath().end());
        unsigned nlaIdx;
        unsigned nlaLen = nlaPath.size();
        for (nlaIdx = 0; nlaIdx < nlaLen; ++nlaIdx) {
          auto innerRef = nlaPath[nlaIdx].dyn_cast<InnerRefAttr>();
          if (!innerRef)
            continue;
          if (innerRef.getModule() == parent.moduleNameAttr() &&
              innerRef.getName() == inst.inner_symAttr())
            break;
        }

        // Handle the case where the instance no longer shows up in the NLA's
        // path. This usually happens if the instance is extracted into multiple
        // parents (because the current parent module is multiply instantiated).
        // In that case NLAs that were specific to one instance may have been
        // moved when we arrive at the second instance, and the NLA is already
        // updated.
        if (nlaIdx >= nlaLen) {
          LLVM_DEBUG(llvm::dbgs() << "    - Instance no longer in path\n");
          return true;
        }
        LLVM_DEBUG(llvm::dbgs() << "    - Position " << nlaIdx << "\n");

        // Handle the case where the NLA's path doesn't go through the
        // instance's new parent module, which happens if the current parent
        // module is multiply instantiated. In that case, we only move over NLAs
        // that actually affect the instance through the new parent module.
        if (nlaIdx > 0) {
          auto innerRef = nlaPath[nlaIdx - 1].dyn_cast<InnerRefAttr>();
          if (innerRef &&
              !(innerRef.getModule() == newParent.moduleNameAttr() &&
                innerRef.getName() == newParentInst.inner_symAttr())) {
            LLVM_DEBUG(llvm::dbgs()
                       << "    - Ignored since NLA parent " << innerRef
                       << " does not pass through extraction parent\n");
            return true;
          }
        }

        // Since we're moving the instance out of its parent module, this NLA
        // will no longer pass through that parent module. Mark it to be removed
        // from the parent later.
        nlasToRemoveFromParent.insert(nla.sym_nameAttr());

        // There are two interesting cases now:
        // - If `nlaIdx == 0`, the NLA is rooted at the module the instance was
        //   located in prior to extraction. This indicates that the NLA applies
        //   to all instances of that parent module. Since we are extracting
        //   *out* of that module, we have to create a new NLA rooted at the new
        //   parent module after extraction.
        // - If `nlaIdx > 0`, the NLA is rooted further up in the hierarchy and
        //   we can simply remove the old parent module from the path.

        // Handle the case where we need to come up with a new NLA for this
        // instance since we've moved it past the module at which the old NLA
        // was rooted at.
        if (nlaIdx == 0) {
          LLVM_DEBUG(llvm::dbgs()
                     << "    - Re-rooting " << nlaPath[nlaIdx] << "\n");
          nlaPath[nlaIdx] =
              InnerRefAttr::get(newParent.moduleNameAttr(),
                                nlaPath[nlaIdx].cast<InnerRefAttr>().getName());
          auto builder = OpBuilder::atBlockBegin(getOperation().getBody());
          // CAVEAT(fschuiki): There are likely cases where the following
          // creates multiple NLAs with the same name. This is going to happen
          // if an NLA has to be re-rooted and the parent is instantiated
          // multiple times, requiring us to create a new NLA for each of the
          // parent instances. To fix this you'll have to pick a name through
          // `circuitNamespace.newName(...)` and visit every module/instance in
          // the old NLA, remove the reference to the old NLA, and add
          // references for all the newly-created ones.
          auto newNla = builder.create<NonLocalAnchor>(
              newInst.getLoc(), nla.sym_nameAttr(),
              builder.getArrayAttr(nlaPath));
          nlasToRemove.insert(nla);
          nlaTable.addNLA(newNla);
          // This modifies our local copy of the anno, not the actual anno on
          // the operation.
          anno.setMember("circt.nonlocal",
                         FlatSymbolRefAttr::get(newNla.sym_nameAttr()));
          newInstAnnos.push_back(anno.getDict());
          LLVM_DEBUG(llvm::dbgs() << "    - Created " << newNla << "\n");
          return true; // delete the old anno
        }

        // In the subequent code block we are going to remove one element from
        // the NLA path, corresponding to the fact that the extracted instance
        // has moved up in the hierarchy by one level. Removing that element may
        // leave the NLA in a degenerate state, with only a single element in
        // its path. If that is the case we have to convert the NLA into a
        // regular local annotation.
        if (nlaPath.size() == 2) {
          anno.removeMember("circt.nonlocal");
          newInstAnnos.push_back(anno.getDict());
          nlasToRemove.insert(nla);
          LLVM_DEBUG(llvm::dbgs()
                     << "    - Converted to local " << anno.getDict() << "\n");
          return true; // delete the old anno
        }

        // At this point the NLA looks like `NewParent::X, OldParent::BB`, and
        // the `nlaIdx` points at `OldParent::BB`. To make our lives easier,
        // since we know that `nlaIdx` is a `InnerRefAttr`, we'll modify
        // `OldParent::BB` to be `NewParent::BB` and delete `NewParent::X`.
        auto newInnerRef = InnerRefAttr::get(
            nlaPath[nlaIdx - 1].cast<InnerRefAttr>().getModule(),
            newInst.inner_symAttr());
        LLVM_DEBUG(llvm::dbgs()
                   << "    - Replacing " << nlaPath[nlaIdx - 1] << " and "
                   << nlaPath[nlaIdx] << " with " << newInnerRef << "\n");
        nlaPath[nlaIdx] = newInnerRef;
        nlaPath.erase(nlaPath.begin() + nlaIdx - 1);
        nla.namepathAttr(builder.getArrayAttr(nlaPath));
        LLVM_DEBUG(llvm::dbgs() << "    - Modified to " << nla << "\n");
        return false;
      });
      annos.addAnnotations(newInstAnnos);
      annos.applyToOperation(newInst);

      // Add the moved instance to the extraction worklist such that it gets
      // bubbled up further if needed.
      extractionWorklist.push_back({newInst, info});
      LLVM_DEBUG(llvm::dbgs() << "  - Updated to " << newInst << "\n");

      // Remove the obsolete NLAs from the instance of the parent module, since
      // the extracted instance no longer resides in that module and any NLAs to
      // it no longer go through the parent module.
      AnnotationSet::removeAnnotations(newParentInst, [&](Annotation anno) {
        auto nlaName = anno.getMember<FlatSymbolRefAttr>("circt.nonlocal");
        if (nlaName && nlasToRemoveFromParent.contains(nlaName.getAttr())) {
          LLVM_DEBUG(llvm::dbgs()
                     << "  - Remove from parent: " << anno.getDict() << "\n");
          return true;
        }
        return false;
      });
      nlasToRemoveFromParent.clear();

      // Keep instance graph up-to-date.
      instanceGraph->replaceInstance(oldParentInst, newParentInst);
      oldParentInst.erase();
    }

    // Clean up the original instance.
    inst.erase();
    newPorts.clear();
  }

  // Remove unused NLAs.
  for (Operation *op : nlasToRemove) {
    LLVM_DEBUG(llvm::dbgs() << "Removing obsolete " << *op << "\n");
    op->erase();
  }
}

/// Group instances into submodules after they have been moved upwards. This
/// only occurs for instances that had the corresponding `dest` field of the
/// annotation set.
void ExtractInstancesPass::groupInstances() {
  // Group the extracted instances by their wrapper module name and their parent
  // module. Note that we cannot group instances that landed in different parent
  // modules into the same submodule, so we use that parent module as a grouping
  // key.
  SmallDenseMap<std::pair<Operation *, StringRef>, SmallVector<InstanceOp>>
      instsByWrapper;
  for (auto &[inst, info] : extractedInstances) {
    if (!info.wrapperModule.empty())
      instsByWrapper[{inst->getParentOfType<FModuleOp>(), info.wrapperModule}]
          .push_back(inst);
  }
  if (instsByWrapper.empty())
    return;
  LLVM_DEBUG(llvm::dbgs() << "\nGrouping instances into wrappers\n");

  // Generate the wrappers.
  SmallVector<PortInfo> ports;
  SmallVector<Attribute> wrapperInstAnnos;
  auto &nlaTable = getAnalysis<NLATable>();

  for (auto &[parentAndWrapperName, insts] : instsByWrapper) {
    auto [parentOp, wrapperName] = parentAndWrapperName;
    auto parent = cast<FModuleOp>(parentOp);
    LLVM_DEBUG(llvm::dbgs() << "- Wrapper `" << wrapperName << "` in `"
                            << parent.moduleName() << "` with " << insts.size()
                            << " instances\n");
    OpBuilder builder(parentOp);

    // Uniquify the wrapper name.
    wrapperName = circuitNamespace.newName(wrapperName);
    auto wrapperInstName =
        builder.getStringAttr(getModuleNamespace(parent).newName(wrapperName));

    // Assemble a list of ports for the wrapper module, which is basically just
    // a concatenation of the wrapped instance ports. Also keep track of the
    // NLAs that target the grouped instances since these will have to pass
    // through the wrapper module.
    ports.clear();
    wrapperInstAnnos.clear();
    for (auto inst : insts) {
      // Determine the ports for the wrapper.
      StringRef prefix(instPrefices[inst]);
      unsigned portNum = inst.getNumResults();
      for (unsigned portIdx = 0; portIdx < portNum; ++portIdx) {
        auto name = inst.getPortNameStr(portIdx);
        auto nameAttr = builder.getStringAttr(
            prefix.empty() ? Twine(name) : Twine(prefix) + "_" + name);
        PortInfo port{nameAttr,
                      inst.getResult(portIdx).getType().cast<FIRRTLType>(),
                      inst.getPortDirection(portIdx)};
        port.loc = inst.getResult(portIdx).getLoc();
        ports.push_back(port);
      }

      // Determine the additional NLA breadcrumbs to put on the wrapper instance
      // and update the NLA's path to include the wrapper instance we're about
      // to construct.
      for (auto anno : AnnotationSet(inst)) {
        auto nlaName = anno.getMember<FlatSymbolRefAttr>("circt.nonlocal");
        if (!nlaName)
          continue;
        auto nla = nlaTable.getNLA(nlaName.getAttr());
        LLVM_DEBUG(llvm::dbgs() << "  - Updating " << nla << "\n");

        // Find the position of the instance in the NLA path. This is going to
        // be the position at which we have to modify the NLA.
        SmallVector<Attribute> nlaPath(nla.namepath().begin(),
                                       nla.namepath().end());
        unsigned nlaIdx;
        unsigned nlaLen = nlaPath.size();
        for (nlaIdx = 0; nlaIdx < nlaLen; ++nlaIdx) {
          auto innerRef = nlaPath[nlaIdx].dyn_cast<InnerRefAttr>();
          if (!innerRef)
            continue;
          if (innerRef.getModule() == parent.moduleNameAttr() &&
              innerRef.getName() == inst.inner_symAttr())
            break;
        }
        assert(nlaIdx < nlaLen && "instance not found in its own NLA");
        LLVM_DEBUG(llvm::dbgs() << "    - Position " << nlaIdx << "\n");

        // The relevant part of the NLA is of the form `Top::bb`, which we want
        // to expand to `Top::wrapperInst` and `Wrapper::bb`.
        auto ref1 = InnerRefAttr::get(
            nlaPath[nlaIdx].cast<InnerRefAttr>().getModule(), wrapperInstName);
        auto ref2 =
            InnerRefAttr::get(builder.getStringAttr(wrapperName),
                              nlaPath[nlaIdx].cast<InnerRefAttr>().getName());
        LLVM_DEBUG(llvm::dbgs() << "    - Expanding " << nlaPath[nlaIdx]
                                << " to (" << ref1 << ", " << ref2 << ")\n");
        nlaPath[nlaIdx] = ref1;
        nlaPath.insert(nlaPath.begin() + nlaIdx + 1, ref2);
        nla.namepathAttr(builder.getArrayAttr(nlaPath));
        LLVM_DEBUG(llvm::dbgs() << "    - Modified to " << nla << "\n");

        // Create a breadcrumb annotation for the wrapper instance which we'll
        // create further down.
        wrapperInstAnnos.push_back(builder.getDictionaryAttr(
            {{builder.getStringAttr("class"),
              builder.getStringAttr("circt.nonlocal")},
             {builder.getStringAttr("circt.nonlocal"),
              FlatSymbolRefAttr::get(nla.sym_nameAttr())}}));
      }
    }

    // Create the wrapper module.
    auto wrapper = builder.create<FModuleOp>(
        builder.getUnknownLoc(), builder.getStringAttr(wrapperName), ports);

    // Instantiate the wrapper module in the parent and replace uses of the
    // extracted instances' ports with the corresponding wrapper module ports.
    // This will essentially disconnect the extracted instances.
    builder.setInsertionPointToStart(parent.getBody());
    auto wrapperInst = builder.create<InstanceOp>(
        wrapper.getLoc(), wrapper, wrapperName, wrapperInstAnnos,
        /*portAnnotations=*/ArrayRef<Attribute>{}, /*lowerToBind=*/false,
        wrapperInstName);
    unsigned portIdx = 0;
    for (auto inst : insts)
      for (auto result : inst.getResults())
        result.replaceAllUsesWith(wrapperInst.getResult(portIdx++));

    // Move all instances into the wrapper module and wire them up to the
    // wrapper ports.
    portIdx = 0;
    builder.setInsertionPointToStart(wrapper.getBody());
    for (auto inst : insts) {
      inst->remove();
      builder.insert(inst);
      for (auto result : inst.getResults()) {
        Value dst = result;
        Value src = wrapper.getArgument(portIdx);
        if (ports[portIdx].direction == Direction::Out)
          std::swap(dst, src);
        builder.create<StrictConnectOp>(result.getLoc(), dst, src);
        ++portIdx;
      }
    }
  }
}

/// Generate trace files, which are plain text metadata files that list the
/// hierarchical path where each instance was extracted from. The file lists one
/// instance per line in the form `<prefix> -> <original-path>`.
void ExtractInstancesPass::createTraceFiles() {
  LLVM_DEBUG(llvm::dbgs() << "\nGenerating trace files\n");
  auto builder = OpBuilder::atBlockEnd(getOperation().getBody());

  // Group the extracted instances by their trace file name.
  SmallDenseMap<StringRef, SmallVector<InstanceOp>> instsByTraceFile;
  for (auto &[inst, info] : extractedInstances)
    if (!info.traceFilename.empty())
      instsByTraceFile[info.traceFilename].push_back(inst);

  // Generate the trace files.
  SmallVector<Attribute> symbols;
  SmallDenseMap<Attribute, unsigned> symbolIndices;

  for (auto &[fileName, insts] : instsByTraceFile) {
    LLVM_DEBUG(llvm::dbgs() << "- " << fileName << "\n");
    std::string buffer;
    llvm::raw_string_ostream os(buffer);
    symbols.clear();
    symbolIndices.clear();

    auto addSymbol = [&](Attribute symbol) {
      unsigned id;
      auto it = symbolIndices.find(symbol);
      if (it != symbolIndices.end()) {
        id = it->second;
      } else {
        id = symbols.size();
        symbols.push_back(symbol);
        symbolIndices.insert({symbol, id});
      }
      os << "{{" << id << "}}";
    };

    for (auto inst : insts) {
      StringRef prefix(instPrefices[inst]);
      if (prefix.empty()) {
        LLVM_DEBUG(llvm::dbgs() << "  - Skipping `" << inst.name()
                                << "` since it has no extraction prefix\n");
        continue;
      }
      ArrayRef<InnerRefAttr> path(extractionPaths[inst]);
      if (path.empty()) {
        LLVM_DEBUG(llvm::dbgs() << "  - Skipping `" << inst.name()
                                << "` since it has not been moved\n");
        continue;
      }
      LLVM_DEBUG(llvm::dbgs()
                 << "  - " << prefix << ": " << inst.name() << "\n");
      os << prefix << " -> ";

      // HACK: To match the Scala implementation, we strip all non-DUT modules
      // from the path and make the path look like it's rooted at the first DUT
      // module (so `TestHarness.dut.foo.bar` becomes `DUTModule.foo.bar`).
      while (!path.empty() &&
             !dutModuleNames.contains(path.back().getModule())) {
        LLVM_DEBUG(llvm::dbgs()
                   << "    - Dropping non-DUT segment " << path.back() << "\n");
        path = path.drop_back();
      }
      // HACK: This is extremely ugly. In case the instance was just moved by a
      // single level, the path may become empty. In that case we simply use the
      // instance's original parent before it was moved.
      addSymbol(FlatSymbolRefAttr::get(path.empty()
                                           ? originalInstanceParents[inst]
                                           : path.back().getModule()));
      for (auto sym : llvm::reverse(path)) {
        os << ".";
        addSymbol(sym);
      }
      os << ".";
      addSymbol(getInnerRefTo(inst));
      os << "\n";
    }

    // Put the information in a verbatim operation.
    auto verbatimOp = builder.create<sv::VerbatimOp>(
        builder.getUnknownLoc(), buffer, ValueRange{},
        builder.getArrayAttr(symbols));
    auto fileAttr = hw::OutputFileAttr::getFromFilename(
        builder.getContext(), fileName, /*excludeFromFilelist=*/true);
    verbatimOp->setAttr("output_file", fileAttr);
  }
}

//===----------------------------------------------------------------------===//
// Pass Creation
//===----------------------------------------------------------------------===//

std::unique_ptr<mlir::Pass> circt::firrtl::createExtractInstancesPass() {
  return std::make_unique<ExtractInstancesPass>();
}
