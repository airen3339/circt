//===- CalyxOps.cpp - Calyx op code defs ------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This is where op definitions live.
//
//===----------------------------------------------------------------------===//

#include "circt/Dialect/Calyx/CalyxOps.h"
#include "circt/Dialect/Calyx/CalyxAttributes.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/BuiltinTypes.h"
#include "mlir/IR/Diagnostics.h"
#include "mlir/IR/DialectImplementation.h"
#include "mlir/IR/FunctionImplementation.h"
#include "mlir/IR/PatternMatch.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/ADT/TypeSwitch.h"

using namespace circt;
using namespace circt::calyx;
using namespace mlir;

//===----------------------------------------------------------------------===//
// ComponentOp
//===----------------------------------------------------------------------===//

static void printPortDefList(OpAsmPrinter &p,
                             SmallVector<BlockArgument, 8> &portDefs) {
  p << '(';

  SmallString<32> tempStr;
  llvm::interleaveComma(portDefs, p, [&](BlockArgument portDef) {
    // Convert to a temporary stream to drop the `%` symbol.
    tempStr.clear();
    llvm::raw_svector_ostream tmpStream(tempStr);
    p.printOperand(portDef, tmpStream);

    p << tmpStream.str().drop_front() << ": " << portDef.getType();
  });

  p << ')';
}

static void printComponentOp(OpAsmPrinter &p, ComponentOp &op) {
  auto name = op->getAttrOfType<SymbolRefAttr>("name");
  p << "component " << name << " ";

  auto portDefs = op.body().front().getArguments();
  auto numInputPorts = op.inputPortCountAttr().getInt();
  auto inputPortsEnd = portDefs.begin() + numInputPorts;

  SmallVector<BlockArgument, 8> inputPortDefs(portDefs.begin(), inputPortsEnd);
  SmallVector<BlockArgument, 8> outputPortDefs(inputPortsEnd, portDefs.end());

  printPortDefList(p, inputPortDefs);
  p << " -> ";
  printPortDefList(p, outputPortDefs);

  // TODO(calyx): Cells, wires and control.
  p.printRegion(op.body(), /*printBlockTerminators=*/false,
                /*printEmptyBlock=*/false);
}

static ParseResult
parsePortDefList(OpAsmParser &parser,
                 SmallVectorImpl<OpAsmParser::OperandType> &portDefs,
                 SmallVectorImpl<Type> &portDefTypes) {
  if (parser.parseLParen())
    return failure();

  do {
    OpAsmParser::OperandType portDef;
    Type portDefType;
    if (failed(parser.parseOptionalRegionArgument(portDef)) ||
        failed(parser.parseColonType(portDefType)))
      continue;
    portDefs.push_back(portDef);
    portDefTypes.push_back(portDefType);
  } while (succeeded(parser.parseOptionalComma()));

  return (parser.parseRParen());
}

static ParseResult
parseComponentSignature(OpAsmParser &parser, OperationState &result,
                        SmallVectorImpl<OpAsmParser::OperandType> &portDefs,
                        SmallVectorImpl<Type> &portDefTypes) {
  if (parsePortDefList(parser, portDefs, portDefTypes))
    return failure();

  // Record the number of input ports.
  IntegerAttr inputCountAttr =
      parser.getBuilder().getI64IntegerAttr(portDefs.size());
  result.addAttribute("inputPortCount", inputCountAttr);

  if (parser.parseArrow() || parsePortDefList(parser, portDefs, portDefTypes))
    return failure();

  return success();
}

static ParseResult parseComponentOp(OpAsmParser &parser,
                                    OperationState &result) {
  SymbolRefAttr name;
  if (parser.parseAttribute(name, "name", result.attributes)) {
    return failure();
  }

  SmallVector<OpAsmParser::OperandType, 8> portDefs;
  SmallVector<Type, 8> portDefTypes;
  if (parseComponentSignature(parser, result, portDefs, portDefTypes))
    return failure();

  // TODO(calyx): Cells, wires and control.
  auto *body = result.addRegion();
  if (parser.parseRegion(*body, portDefs, portDefTypes))
    return failure();

  return success();
}

//===----------------------------------------------------------------------===//
// TableGen generated logic.
//===----------------------------------------------------------------------===//

// Provide the autogenerated implementation guts for the Op classes.
#define GET_OP_CLASSES
#include "circt/Dialect/Calyx/Calyx.cpp.inc"
